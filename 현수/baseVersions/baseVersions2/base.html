<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í—ˆì ‘ ë“œë˜ê³¤ í”Œë¼ì´íŠ¸</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #222;
        }

        canvas {
            border: 2px solid #fff;
            background-color: #000;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
</head>

<body>

    <script>
        const config = {
            type: Phaser.AUTO,
            width: 480, // ê²Œì„ í™”ë©´ ë„ˆë¹„ (ì˜ˆ: ëª¨ë°”ì¼ í™”ë©´)
            height: 640, // ê²Œì„ í™”ë©´ ë†’ì´
            parent: 'game-container', // HTMLì— id='game-container'ì¸ divê°€ ì—†ìœ¼ë©´ bodyì— ë¶™ìŠµë‹ˆë‹¤.
            physics: {
                default: 'arcade',
                arcade: {
                    debug: false // ì¶©ëŒ ë°•ìŠ¤ë¥¼ ë³´ë ¤ë©´ true
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const game = new Phaser.Game(config);

        let player;
        let bullets;
        let enemies;
        let lastFired = 0; // ì´ì•Œ ë°œì‚¬ ë”œë ˆì´ë¥¼ ìœ„í•œ ì‹œê°„
        let score = 0;
        let scoreText;
        let gameOver = false;

        //--------ìˆ˜ì •1-----------------------------------------------
        let battleOn = true;      // ì „íˆ¬ ìƒíƒœ í”Œë˜ê·¸ (ON/OFF)
        let enemySpawnEvent;      // ì  ìŠ¤í° íƒ€ì´ë¨¸ ì €ì¥ìš©
        let carrierEventOn = false;
        let docking = {
            active: false,
            carrier: null,
            guide: null,
            guideLeftX: 200,
            guideRightX: 280,
            tolerance: 18,
            descentPxPerSec: 60,
            targetY: 0,
            lockOffsetPx: 0   // ğŸ‘ˆ ì¶”ê°€: â€˜ì•„ë˜ì—ì„œ ì–¼ë§ˆë‚˜ ìœ„â€™ë¥¼ ë½ íŒì •ì„ ìœ¼ë¡œ ì“¸ì§€
        };
        let sway = {
            active: false,
            locked: false,        // ì ‘ì´‰ í›„ ê³ ì • ìƒíƒœ
            playerBaseX: null,    // ì…ë ¥ìœ¼ë¡œ ì •í•œ ê¸°ì¤€ x
            playerPhase: 0,       // í”Œë ˆì´ì–´ í”ë“¤ë¦¼ ìœ„ìƒ
            playerAmp: 14,        // í”Œë ˆì´ì–´ í”ë“¤ë¦¼ ì§„í­(px)
            playerHz: 0.9,        // í”Œë ˆì´ì–´ í”ë“¤ë¦¼ ì£¼íŒŒìˆ˜(Hz)
            carrierAmp: 26,       // í•­ëª¨ í”ë“¤ë¦¼ ì§„í­(px)
            carrierTween: null    // í•­ëª¨ ì¢Œìš° ë“œë¦¬í”„íŠ¸ íŠ¸ìœˆ í•¸ë“¤
        };
        let __engineShutdownPlayed = false;

        function spawnEnemy() {
            if (gameOver || !battleOn) return;

            let x = Phaser.Math.Between(50, config.width - 50);
            let enemy = enemies.create(x, -50, 'enemy')
                .setOrigin(0.5, 0.5)
                .setDisplaySize(30, 30)
                .setTint(0xff0000);

            enemy.setVelocityY(Phaser.Math.Between(50, 150));
            enemy.body.setSize(30, 30);
            enemy.body.collideWorldBounds = false;
            enemy.body.bounce.set(1);
        }

        function setBattle(on) {
            battleOn = on;
            if (enemySpawnEvent) enemySpawnEvent.paused = !on; // ìŠ¤í° íƒ€ì´ë¨¸ ì¼ì‹œì •ì§€/ì¬ê°œ
        }

        function startCarrierApproach(scene) {
            if (carrierEventOn) return;   // â¬… ì¶”ê°€
            carrierEventOn = true;        // â¬… ì¶”ê°€

            setBattle(false);

            const carrierTexture = scene.textures.get('carrier').getSourceImage();
            const carrierHeight = carrierTexture.height;

            const carrier = scene.add.image(config.width / 2, config.height + carrierHeight, 'carrier')
                .setOrigin(0.5, 1)
                .setScale(0.48)   // ì²« ë“±ì¥ 20% ì¶•ì†Œ
                .setDepth(20);

            // 1ë‹¨ê³„: ë°‘ì—ì„œ ìœ„ë¡œ ë¹ ì§
            scene.tweens.add({
                targets: carrier,
                y: -80,
                duration: 6100,
                ease: 'Sine.easeInOut',
                onComplete: () => {
                    // 2ë‹¨ê³„: ìƒë‹¨ì—ì„œ í¬ê²Œ ì¬ë“±ì¥ (í•˜ë‹¨ 2/5ë§Œ í‘œì‹œ)
                    const VISIBLE_RATIO = 2 / 5;
                    const srcH = scene.textures.get('carrier').getSourceImage().height;

                    carrier.setScale(1.0);
                    carrier.y = -srcH * 0.6;  // í™”ë©´ ìœ„ì—ì„œ ì‹œì‘
                    carrier.alpha = 0;

                    const targetVisibleY = carrier.displayHeight * VISIBLE_RATIO;

                    // ì•ŒíŒŒ + ìœ„ì¹˜ íŠ¸ìœˆ (ëë‚˜ë©´ ë„í‚¹ ì‹œì‘)
                    scene.tweens.add({
                        targets: carrier,
                        y: targetVisibleY,
                        alpha: 1,
                        duration: 3000,              // ì¬ë“±ì¥ ì†ë„ (ì›í•˜ë©´ 3500~4500ìœ¼ë¡œ ëŠ¦ì¶”ê¸°)
                        ease: 'Cubic.easeOut',
                        onComplete: () => {
                            // ğŸ”¹ ì—¬ê¸°ì„œ ë„í‚¹ ë¯¸ë‹ˆê²Œì„ ì‹œì‘!
                            startCarrierDocking(scene, carrier);
                        }
                    });

                    // (ì„ íƒ) ë©ì¹˜ê° ë¸Œë¦¬ë”©
                    scene.tweens.add({
                        targets: carrier,
                        scaleX: 1.02,
                        scaleY: 1.02,
                        duration: 700,
                        yoyo: true,
                        repeat: 1,
                        ease: 'Sine.easeInOut'
                    });
                }
            });
        }

        function drawGuides(scene, aligned) {
            if (!docking.guide) {
                docking.guide = scene.add.graphics().setDepth(5); // ìœ ë„ì„ ì€ ê°€ì¥ ë’¤
            }
            const g = docking.guide;
            g.clear();

            const color = aligned ? 0x33e0ff : 0x3399ff;
            g.lineStyle(3, color, 1);

            // ----- ì—¬ê¸°ë¶€í„° 'ìƒë‹¨ ë°˜ë§Œ ìë¥´ê¸°' ë¡œì§ -----
            // carrierì˜ ì„¸ë¡œ ì¤‘ì•™ ì¢Œí‘œ (origin 0.5, 1 ì´ë¯€ë¡œ y - displayHeight/2)
            let topCropY = 0;
            if (docking.carrier) {
                const carrierMidY = docking.carrier.y - docking.carrier.displayHeight / 2;
                // í•­ëª¨ì˜ 'ì¤‘ì•™'ì´ í™”ë©´ ì¤‘ì•™ì„ ì§€ë‚˜ë©´ ìœ„ìª½ì„ ì˜ë¼ë‚´ê³  í•˜ë‹¨ë§Œ ë‚¨ê¹€
                if (carrierMidY >= config.height / 2) {
                    topCropY = config.height / 2; // í™”ë©´ ì¤‘ì•™ë¶€í„° ì•„ë˜ë§Œ ê·¸ë¦¼
                }
            }
            // -----------------------------------------

            // ì ì„ ì²˜ëŸ¼ ë³´ì´ê²Œ ì„¸ê·¸ë¨¼íŠ¸ë¡œ ë‘ ì¤„ ëª¨ë‘ ê·¸ë¦¼
            const seg = 12, gap = 8, bottom = config.height;

            // ì™¼ìª½ ë¼ì¸
            let y = topCropY;
            while (y < bottom) {
                g.strokeLineShape(new Phaser.Geom.Line(docking.guideLeftX, y, docking.guideLeftX, Math.min(y + seg, bottom)));
                y += seg + gap;
            }

            // ì˜¤ë¥¸ìª½ ë¼ì¸
            y = topCropY;
            while (y < bottom) {
                g.strokeLineShape(new Phaser.Geom.Line(docking.guideRightX, y, docking.guideRightX, Math.min(y + seg, bottom)));
                y += seg + gap;
            }
        }

        function startCarrierDocking(scene, carrier) {
            docking.active = true;
            docking.carrier = carrier;

            // ì¤‘ì•™ ê¸°ì¤€ ì¢Œìš°ë¡œ ë²Œë¦° ë‘ ì„  (ì›í•˜ë©´ ìˆ˜ì¹˜ ì¡°ì •)
            const center = config.width / 2;
            const halfGap = 24; // ë¼ì¸ ê°„ê²© ì ˆë°˜ (ì´ ê°„ê²© 80px)
            docking.guideLeftX = center - halfGap;
            docking.guideRightX = center + halfGap;

            docking.tolerance = 12;
            docking.descentPxPerSec = 40;
            docking.targetY = docking.carrier.displayHeight * 0.95;

            drawGuides(scene, false);

            sway.active = true; //í”ë“¤ë¦¼ ì‹œì‘
            sway.locked = false;
            if (sway.carrierTween) { sway.carrierTween.remove(); sway.carrierTween = null; }

            docking.lockOffsetPx = docking.carrier.displayHeight * 0.3;
            docking.ascentPxPerSec = 20;    // ì •ë ¬ ì•ˆ ëì„ ë•Œ ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” ì†ë„(íŠœë‹ ê°€ëŠ¥)
            docking.minY = carrier.y;       // ë„í‚¹ ì‹œì‘ ë‹¹ì‹œì˜ yë³´ë‹¤ ë” ìœ„ë¡œëŠ” ëª» ì˜¬ë¼ê°€ê²Œ ìƒí•œ
        }

        function lockToCenter(scene) {
            sway.locked = true;          // ì¡°ì‘ ë§‰ìŒ
            sway.active = true;          // (í”ë“¤ë¦¼ ì‹œìŠ¤í…œì€ ìœ ì§€)
            setBattle(false);            // ì „íˆ¬ëŠ” ê³„ì† OFF ìœ ì§€

            const cx = config.width / 2;

            // ìœ ë„ì„ /í•­ëª¨/í”Œë ˆì´ì–´ ëª¨ë‘ ì¤‘ì•™ ì •ë ¬
            // (í•­ëª¨ëŠ” ë¶€ë“œëŸ½ê²Œ, í”Œë ˆì´ì–´ëŠ” ì§§ê²Œ)
            if (sway.carrierTween) { sway.carrierTween.remove(); sway.carrierTween = null; }
            scene.tweens.add({
                targets: docking.carrier,
                x: cx,
                duration: 600,
                ease: 'Sine.easeInOut'
            });

            scene.tweens.add({
                targets: player,
                x: cx,
                duration: 300,
                ease: 'Sine.easeOut'
            });

            // í”Œë ˆì´ì–´ ì…ë ¥ ë¬´ì‹œ: ê¸°ì¤€ xë„ ì¤‘ì•™ìœ¼ë¡œ ê³ ì •
            sway.playerBaseX = cx;

            // (ì„ íƒ) ìœ ë„ì„ ë„ ì¤‘ì•™ì— ë§ì¶˜ë‹¤ë©´:
            docking.guideLeftX = cx - (docking.guideRightX - docking.guideLeftX) / 2;
            docking.guideRightX = cx + (docking.guideRightX - docking.guideLeftX) / 2;
        }

        function playEngineShutdown(scene) {
            if (__engineShutdownPlayed) return;
            __engineShutdownPlayed = true;

            // ì•ˆì „: ì…ë ¥/ì „íˆ¬ ì ê¹ ë¬¶ê¸°
            setBattle(false);
            sway.locked = true;

            // ë‹¨ê³„ë³„ í…ìŠ¤ì²˜ êµì²´
            scene.time.delayedCall(1000, () => player.setTexture('playerShip_2'));
            scene.time.delayedCall(1000, () => player.setTexture('playerShip_1'));
            scene.time.delayedCall(2000, () => player.setTexture('playerShip_0'));

            // í•„ìš”í•˜ë©´ ëë‚œ ë’¤ ì½œë°±(ì˜ˆ: ìƒì  ì§„ì…)ì„ ì—¬ê¸°ì„œ ì´ì–´ë¶™ì¼ ìˆ˜ ìˆìŒ
            // scene.time.delayedCall(3000, () => { openShop(scene); });
        }

        //-----------------ì—¬ê¸°ê¹Œì§€---------------------

        function preload() {
            this.load.image('playerShip', 'assets/player/player1.png');
            this.load.image('playerShip_2', 'assets/player/player1_2.png'); // ì í™” ê°•
            this.load.image('playerShip_1', 'assets/player/player1_1.png'); // ì í™” ì•½
            this.load.image('playerShip_0', 'assets/player/player1_0.png'); // ì†Œë“±

            this.load.image('carrier', 'assets/player/carrier1.png'); // ê²½ë¡œì— ë§ê²Œ ìˆ˜ì •
        }

        function create() {

            this.bKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.B); // í…ŒìŠ¤íŠ¸ ì¹˜íŠ¸í‚¤


            // ë°°ê²½ìƒ‰ ì„¤ì • (CSSì˜ background-colorì™€ ìº”ë²„ìŠ¤ ë‚´ë¶€ì˜ ë°°ê²½ìƒ‰)
            this.cameras.main.setBackgroundColor('#000033'); // ì§„í•œ íŒŒë€ìƒ‰ ë°°ê²½

            // í”Œë ˆì´ì–´ (ì‚¬ê°í˜•) ìƒì„±
            player = this.physics.add.image(config.width / 2, config.height - 50, 'playerShip')
                .setOrigin(0.5, 0.5)
                .setScale(0.07);
            player.setDepth(40);

            player.setCollideWorldBounds(true); // í™”ë©´ ë°–ìœ¼ë¡œ ëª» ë‚˜ê°€ê²Œ

            // ì´ì•Œ ê·¸ë£¹ ìƒì„±
            bullets = this.physics.add.group({
                defaultKey: 'bullet',
                maxSize: 100 // ìµœëŒ€ 100ê°œì˜ ì´ì•Œ
            });
            // ì´ì•Œ ëª¨ì–‘ (ì‘ì€ í°ìƒ‰ ì‚¬ê°í˜•)
            bullets.createMultiple({
                key: 'bullet',
                active: false,
                visible: false,
                repeat: 99, // 100ê°œ ë§Œë“­ë‹ˆë‹¤.
                setXY: { x: -100, y: -100 }, // í™”ë©´ ë°–ìœ¼ë¡œ ì´ˆê¸° ìœ„ì¹˜
                setOrigin: { x: 0.5, y: 0.5 },
                setScale: { x: 0.5, y: 0.5 },
                setTint: 0xffffff, // í°ìƒ‰
                enable: true,
            });
            bullets.children.entries.forEach(bullet => {
                bullet.body.setSize(10, 20); // ì¶©ëŒ ë°•ìŠ¤ í¬ê¸°
            });


            // ì  ê·¸ë£¹ ìƒì„±
            enemies = this.physics.add.group();

            // ì  ìƒì„± ì´ë²¤íŠ¸ (2ì´ˆë§ˆë‹¤)
            enemySpawnEvent = this.time.addEvent({
                delay: 2000,
                callback: spawnEnemy,
                callbackScope: this,
                loop: true
            });

            // ì ìˆ˜ í…ìŠ¤íŠ¸
            scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '24px', fill: '#fff' });

            // ë§ˆìš°ìŠ¤/í„°ì¹˜ ì…ë ¥ ì„¤ì • // ìˆ˜ì •o
            this.input.on('pointermove', (pointer) => {
                if (gameOver) return;
                if (!sway.locked) {
                    sway.playerBaseX = Phaser.Math.Clamp(pointer.x, 20, config.width - 20);
                    if (!sway.active) {
                        // ğŸ”§ í”ë“¤ë¦¼ ë¹„í™œì„± ìƒíƒœì—ì„œëŠ” ë°”ë¡œ ë”°ë¼ê°€ê²Œ
                        player.x = sway.playerBaseX;
                    }
                }
            });

            // ì¶©ëŒ ì²˜ë¦¬: ì´ì•Œê³¼ ì 
            this.physics.add.overlap(bullets, enemies, hitEnemy, null, this);
            // ì¶©ëŒ ì²˜ë¦¬: í”Œë ˆì´ì–´ì™€ ì  (ê²Œì„ ì˜¤ë²„)
            this.physics.add.overlap(player, enemies, hitPlayer, null, this);

            sway.playerBaseX = config.width / 2; //ì—¬ê¸°ë„ ìˆ˜ì •o
            player.x = sway.playerBaseX; //
        }

        function update(time) {
            if (gameOver) return;

            //--------------------------------ìˆ˜ì •ë¶€---------------------

            if (docking.active) {
                updateCarrierDocking(this, this.game.loop.delta);
            }

            // ğŸ”¹ Bí‚¤: battle OFF (ì  ìŠ¤í° + ìƒˆ íƒ„ ë°œì‚¬ ì •ì§€)
            if (Phaser.Input.Keyboard.JustDown(this.bKey)) {
                startCarrierApproach(this);
            }

            // ===== í”ë“¤ë¦¼ ì ìš©(í”Œë ˆì´ì–´) & ì ‘ì´‰ ê°ì§€ =====
            if (sway.active) {
                if (!sway.locked) {
                    const dt = this.game.loop.delta / 1000;
                    sway.playerPhase += dt * (2 * Math.PI * sway.playerHz);
                    const offset = Math.sin(sway.playerPhase) * sway.playerAmp;

                    const targetX = Phaser.Math.Clamp((sway.playerBaseX ?? player.x) + offset, 20, config.width - 20);
                    player.x = targetX;
                }

                if (docking.active && docking.carrier && !sway.locked) {
                    const playerTopY = player.y - player.displayHeight / 2;

                    // ğŸ‘‡ â€˜ì‹¤ì œ ë½ ë¼ì¸â€™: í•­ëª¨ì˜ ë³´ì´ëŠ” ë°”ë‹¥(y)ì—ì„œ lockOffsetPx ë§Œí¼ ìœ„
                    const lockLineY = docking.carrier.y - docking.lockOffsetPx;

                    if (playerTopY <= lockLineY) {
                        lockToCenter(this);
                    }
                }

            } else {
                // ğŸ”§ í”ë“¤ë¦¼ ë¹„í™œì„± ìƒíƒœ: ë§ˆìš°ìŠ¤ ê¸°ì¤€ê°’ìœ¼ë¡œ ë°”ë¡œ ìœ„ì¹˜ ë°˜ì˜
                if (!sway.locked && sway.playerBaseX != null) {
                    player.x = sway.playerBaseX;
                }
            }

            // ì´ì•Œ ìë™ ë°œì‚¬ (ë”œë ˆì´ 200ms)
            // ğŸ”¹ ìƒˆ íƒ„ ë°œì‚¬(ìë™ ì‚¬ê²©) â€” battleOnì¼ ë•Œë§Œ
            if (battleOn && time > lastFired + 200) {
                let bullet = bullets.get(player.x, player.y - 20);
                if (bullet) {
                    bullet.setActive(true).setVisible(true);
                    bullet.body.enable = true;
                    bullet.setVelocityY(-400);
                    lastFired = time;
                }
            }

            function updateCarrierDocking(scene, deltaMs) {
                if (!docking.active || !docking.carrier) return;

                const left = docking.guideLeftX - docking.tolerance;
                const right = docking.guideRightX + docking.tolerance;
                const aligned = (player.x >= left && player.x <= right);

                drawGuides(scene, aligned);

                if (aligned) {
                    // ì •ë ¬ ìƒíƒœ: í•­ëª¨ê°€ í•˜ê°•
                    const dy = (docking.descentPxPerSec * deltaMs) / 1000;
                    docking.carrier.y = Math.min(docking.carrier.y + dy, docking.targetY);
                } else {
                    // ì •ë ¬ì—ì„œ ë²—ì–´ë‚˜ë©´ ì²œì²œíˆ ìœ„ë¡œ ìƒìŠ¹
                    const uy = (docking.ascentPxPerSec * deltaMs) / 1000;
                    // ë„í‚¹ ì‹œì‘ ì‹œì ë³´ë‹¤ ë” ìœ„ë¡œëŠ” ëª» ì˜¬ë¼ê°€ê²Œ
                    docking.carrier.y = Math.max(docking.minY, docking.carrier.y - uy);
                }

                // ì°©í•¨ ì™„ë£Œ íŒì •
                if (docking.carrier.y >= docking.targetY - 0.5) {
                    docking.active = false;
                    if (docking.guide) {
                        docking.guide.destroy();
                        docking.guide = null;
                    }
                    scene.add.text(config.width / 2, config.height / 2, 'ì°©í•¨ ì„±ê³µ!',
                        { fontSize: '28px', fill: '#fff' }).setOrigin(0.5).setDepth(80);

                    carrierEventOn = false;

                    // âœ… ì—”ì§„ ì†Œë“± ì—°ì¶œ
                    playEngineShutdown(scene);
                }
            }


            //-------------------------ì—¬ê¸°ê¹Œì§€-----------------------

            // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°„ ì´ì•Œ ë¹„í™œì„±í™”
            bullets.children.each(function (b) {
                if (b.active && b.y < 0) {
                    b.setActive(false).setVisible(false);
                    b.body.enable = false; // ë¬¼ë¦¬ ë¹„í™œì„±í™”
                }
            });

            // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°„ ì  ë¹„í™œì„±í™” (ì•„ë˜ë¡œ ë‚˜ê°)
            enemies.children.each(function (enemy) {
                if (enemy.active && enemy.y > config.height + 50) {
                    enemy.setActive(false).setVisible(false);
                    enemy.body.enable = false;
                }
            });
        }

        function hitEnemy(bullet, enemy) {
            // ì´ì•Œê³¼ ì ì´ ë¶€ë”ªíˆë©´ ë‘˜ ë‹¤ ë¹„í™œì„±í™”
            bullet.setActive(false).setVisible(false);
            bullet.body.enable = false;

            enemy.setActive(false).setVisible(false);
            enemy.body.enable = false;

            score += 10;
            scoreText.setText('Score: ' + score);
        }

        function hitPlayer(player, enemy) {
            if (gameOver) return;

            // í”Œë ˆì´ì–´ê°€ ì ì—ê²Œ ë§ìœ¼ë©´ ê²Œì„ ì˜¤ë²„
            this.physics.pause();
            player.setTint(0xff0000); // í”Œë ˆì´ì–´ë¥¼ ë¹¨ê°›ê²Œ
            gameOver = true;

            this.add.text(config.width / 2, config.height / 2, 'GAME OVER', { fontSize: '48px', fill: '#fff' }).setOrigin(0.5);
            this.add.text(config.width / 2, config.height / 2 + 60, 'Restart F5', { fontSize: '24px', fill: '#fff' }).setOrigin(0.5);
        }

        // PhaserëŠ” ì´ë¯¸ì§€ë¥¼ ë¡œë“œí•˜ì§€ ì•Šìœ¼ë©´ ê°ì²´ë¥¼ ë§Œë“¤ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ,
        // ë”ë¯¸ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•˜ëŠ” í—¬í¼ í•¨ìˆ˜ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤. (create í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ê¸° ì „ì—)
        Phaser.GameObjects.GameObjectFactory.register('image', function (x, y, key, frame) {
            if (!this.scene.textures.exists(key)) {
                // í•´ë‹¹ í‚¤ì˜ í…ìŠ¤ì²˜ê°€ ì—†ìœ¼ë©´ ë¹ˆ í…ìŠ¤ì²˜ë¥¼ ë§Œë“­ë‹ˆë‹¤.
                let graphics = this.scene.add.graphics({ fillStyle: { color: 0xffffff } });
                graphics.fillRect(0, 0, 32, 32); // 32x32 í°ìƒ‰ ì‚¬ê°í˜•
                graphics.generateTexture(key, 32, 32);
                graphics.destroy();
            }
            return this.displayList.add(new Phaser.GameObjects.Image(this.scene, x, y, key, frame));
        });


    </script>

</body>

</html>